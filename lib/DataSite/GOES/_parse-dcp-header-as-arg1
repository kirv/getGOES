#!/usr/bin/perl -w
use strict;
use warnings;

my $hdr = shift;
die "no header provided\n" unless $hdr;

my @hdr = parse_header($hdr)
    or die;

my @tags = qw(
    address year day hour minute second failcode
    qsignalstrength qfreqofs qmodulation qdata
    channel spacecraft uplink
    datalen
    );

print "@hdr\n";
while ( @tags ) {
    printf("%s = %s\n", shift @tags, shift @hdr);
    }
    
sub parse_header { 
    my $header = shift; 
    my @h = $header =~ m/
        (.{8}) #  0 - ADDRESS 8 DCP address 
        (..)   #  1 + YEAR 2 Year message was received
        (...)  #  2 + DOY 3 Day of year message received
        (..)   #  3 + HOUR 2 Hour message was received
        (..)   #  4 + MINUTE 2 Minute message was received
        (..)   #  5 + SECOND 2 Second message was received
        (.)    #  6 + FAILURE_CODE 1 Code for message (see Notes)
        (..)   #  7 + SIGNAL_STRENGTH 2 DAMS quality measurement
        (..)   #  8 + FREQUENCY_OFFSET 2 DAMS quality measurement
        (.)    #  9 + MODULATION_INDEX 1 DAMS quality measurement
        (.)    # 10 + DATA_QUALITY 1 DAMS quality measurement
        (...)  # 11 - CHANNEL_RECEIVED 3 Channel message received on
        (.)    # 12 - GOES_SPACECRAFT 1 GOES spacecraft used
        (..)   # 13 - UPLINK_CARRIER_STATUS 2 Uplink carrier status
        (.{5}) # 14 + MESSAGE_DATA_LENGTH 5 Message length (bytes) (see Notes)
        /x;
    warn("ERROR PARSING HEADER:$header") && 
        return("ERROR PARSING HEADER:$header") unless @h;

    # timestamp format:       YY DDD / HH : MM : SS
    my $timestamp = sprintf "%02d%03d/%02d:%02d:%02d", 
        $h[1], $h[2], $h[3], $h[4], $h[5];

    # return the 15 header fields, plus the timestamp
    return @h, $timestamp;
    }
